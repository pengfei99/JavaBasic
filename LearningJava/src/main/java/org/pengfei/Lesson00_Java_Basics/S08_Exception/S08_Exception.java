package org.pengfei.Lesson00_Java_Basics.S08_Exception;

import org.pengfei.Lesson00_Java_Basics.S08_Exception.source.ExceptionExp1;
import org.pengfei.Lesson00_Java_Basics.S08_Exception.source.NonIntResultException;

public class S08_Exception {

    /******************************************** 8. Introduction *******************************************/

    /*
    * In this section, we discusses exception handling. An exception is an error that occurs at run time.
    * A principal advantage of Java exception handling is that it automates much of the error handling code that
    * previously had to be entered “by hand” into any large program.
    *
    * Another reason that exception handling is important is that Java defines standard exceptions for common
    * program errors, such as divide­by­zero or file­not­found. To respond to these errors, your program must watch
    * for and handle these exceptions. Also, Java’s API library makes extensive use of exceptions.
    *
    * We will learn the following key points in this section:
    * - Know the exception hierarchy
    * - EXCEPTION HANDLING FUNDAMENTALS
    * - Understand the effects of an uncaught exception
    * - Use multiple catch statements
    * - Catch subclass exceptions
    * - Nest try blocks
    * - Throw an exception
    * - Know the members of Throwable
    * - Use finally
    * - Use throws
    * - Know Java’s built­in exceptions
    * - Create custom exception classes
    * */

    /************************************** 8.1 The exception hierarchy *************************************/

    /*
    * In Java, all exceptions are represented by classes. All exception classes are derived from a class called
    * Throwable. Thus, when an exception occurs in a program, an object of some type of exception class is generated.
    * There are two direct subclasses of Throwable:
    * - Exception : Exception of type Exception are related to errors that result from your program activity. For
    *               example, divide-by-zero, array boundary, and file errors. In general, your program should handle
    *               exceptions of these types. An important subclass is RuntimeException, which is used to represent
    *               various common types of run-time errors.
    * - Error: Exception of type Error are related to errors that occur in the Java Virtual Machine itself, and not in
    *          your program. These types of exceptions are beyond your control, and your program will not usually deal
    *          with them.
    *
    * Check my wiki to see the complete exception hierarchy id=employes:pengfei.liu:java:exception_hierarchy
    * */

    /************************************** 8.2 Exception handling basics *************************************/

    /*
    * Java exception handling is managed via five keywords: try, catch, throw, throws, and finally. They form an
    * interrelated subsystem in which the use of one implies the use of another.
    *
    * Program statements that you want to monitor for exceptions are contained within a try block. If an exception
    * occurs within the try block, it is thrown. Your code can catch this exception using catch and handle it in some
    * rational manner. System­generated exceptions are automatically thrown by the Java run­time system. To manually
    * throw an exception, use the keyword throw. In some cases, an exception that is thrown out of a method must be
    * specified as such by a throws clause. Any code that absolutely must be executed upon exiting from a try block is
    * put in a finally block.
    * */

    /** 8.2.1 Which program conditions cause an exception?
     *
     * Exceptions are generated in three different ways:
     * 1. JVM can generate an exception in response to some internal error which is beyond your control. Normally, your
     *    program won't handle these types of exceptions.
     * 2. Standard exceptions, such as those corresponding to array index out-of-bounds, are generated by errors in
     *    program code. Your program need to handle these exceptions.
     * 3. You can manually generate an exception by using throw statement.
     *
     * No matter how an exception is generated, it is handled in the same way.
     * */

    /** 8.2.2 Using try and catch
     * At the core of exception handling are try and catch. These keywords work together; you can’t have a catch
     * without a try. Here is the general form of the try/catch exception handling blocks:
     *
     * try {
     *    // block of code to monitor for errors
     * }
     * catch (ExcepType1 exOb) {
     *    // handler for ExcepType1
     * }
     * catch (ExcepType2 exOb) {
     *    // handler for ExcepType2
     * }
     *
     * Here, ExcepType is the type of exception that has occurred. When an exception is thrown, it is caught by its
     * corresponding catch statement, which then processes the exception. As the general form shows, there can be more
     * than one catch statement associated with a try. The type of the exception determines which catch statement is
     * executed. That is, if the exception type specified by a catch statement matches that of the exception, then
     * that catch statement is executed (and all others are bypassed). When an exception is caught, exOb will receive
     * its value.
     *
     * Here is an important point: If no exception is thrown, then a try block ends normally, and all of its catch
     * statements are bypassed. Execution resumes with the first statement following the last catch. Thus, catch
     * statements are executed only if an exception is thrown.
     *
     * There is another form of the try statement that supports automatic resource management. This form of try is
     * called "try­with­resources". It is described in section 9, in the context of managing I/O streams (such as
     * those connected to a file) because streams are some of the most commonly used resources.
     *
     * Check the ExceptionExp1.exp1(); to see the code execution order when an exception is generated. Notice, first the
     * code that you want to monitor for errors is contained within a try block. Second, when an exception occurs
     * (in this case, because of the attempt to index nums beyond its bounds), the exception is thrown out of the try
     * block and caught by the catch statement. At this point, control passes to the catch, and the try block is
     * terminated. That is, catch is not called. Rather, program execution is transferred to it. Thus, the println( )
     * statement following the out­of­bounds index will never execute. After the catch statement executes, program
     * control continues with the statements following the catch. Thus, it is the job of your exception handler to
     * remedy the problem that caused the exception so that program execution can continue normally.
     * Remember, if no exception is thrown by a try block, no catch statements will be executed and program control
     * resumes after the catch statement. For example, if we change nums[7]=10 to nums[0]=10; Now, no exception is
     * generated, and the catch block is not executed.
     *
     * It is important to understand that all code within a try block is monitored for exceptions. This includes
     * exceptions that might be generated by a method called from within the try block. An exception thrown by a
     * method called from within a try block can be caught by the catch statements associated with that try
     * block—assuming, of course, that the method did not catch the exception itself. Check  ExceptionExp1.exp2();
     *
     * */

    /************************************** 8.3 The uncaught exception *************************************/

    /*
    * Catching one of Java’s standard exceptions, as the preceding program does, has a side benefit: It prevents
    * abnormal program termination. When an exception is thrown, it must be caught by some piece of code, somewhere.
    * In general, if your program does not catch an exception, then it will be caught by the JVM. The trouble is that
    * the JVM’s default exception handler terminates execution and displays a stack trace and errormessage.
    *
    * Check ExceptionExp1.exp3(); the program execution is halted, and error message is displayed. This is why it is
    * important for your program to handle exceptions itself, rather than rely upon the JVM.
    *
    * As mentioned earlier, the type of the exception must match the type specified in a catch statement. If it does not,
    * the exception won’t be caught. Check ExceptionExp1.exp4(); in the catch clause we try to catch
    * IllegalArgumentException. So the outofbound exception is never catch. Then JVM do the catch.
     * */

    /** 8.3.1 Exceptions Enable You to Handle Errors Gracefully
     *
     * One of the key benefits of exception handling is that it enables your program to respond to an error and then
     * continue running. Check  ExceptionExp1.exp5(); if we don't have the try clause, after entering 0, the program
     * will be halted by JVM.
     *
     * */

    /************************************** 8.4 Using multiple catch statements *************************************/

    /*
    * As stated earlier, you can associate more than one catch statement with a try. In fact, it is common to do so.
    * However, each catch must catch a different type of exception.
    *
    * In general, each catch statement responds only to its own type of exception. Each catch expressions are checked
    * in the order in which they occur in a program. Only a matching statement is executed. All other catch blocks are
    * ignored.
    * */

    /************************************** 8.5 Catch subclass exceptions *************************************/

    /*
    * There is one important point about multiple catch statements that relates to subclasses. A catch clause for
    * a superclass will also match any of its subclasses. For example, since the superclass of all exceptions is
    * Throwable, to catch all possible exceptions, catch Throwable. If you want to catch exceptions of both a
    * superclass type and a subclass type, put the subclass first in the catch sequence. If you don’t, then the
    * superclass catch will also catch all derived classes. This rule is self­enforcing because putting the superclass
    * first causes unreachable code to be created, since the subclass catch clause can never execute. In Java,
    * unreachable code is an error.
    *
    * Check ExceptionExp1.exp6(); catch(Throwable) catches all exceptions except for ArrayIndexOutOfBounds­Exception.
    * The issue of catching subclass exceptions becomes more important when you create exceptions of your own.
     * */

    /** 8.5.1 Why would I want to catch superclass exceptions?
     * 1. If you add catch clause that catches exceptions of type Exception, then you have effectively
     *    added a “catch all” clause to your exception handler that deals with all program related exceptions.
     *    Such a “catch all” clause might be useful in a situation in which abnormal program termination must
     *    be avoided no matter what occurs
     * 2. In some situations, an entire category of exceptions can be handled by the same clause. Catching the
     *    superclass of these exceptions allows you to handle all without duplicated code.
     * */

    /************************************** 8.6 Nest try block *************************************/

    /*
    * One try block can be nested within another. An exception generated within the inner try block that is not
    * caught by a catch associated with that try is propagated to the outer try block. In ExceptionExp1.exp7();
    * ArrayIndexOutOfBoundsException is not caught by the inner catch, but by the outer catch. In this example,
    * an exception that can be handled by the inner try—in this case, a divide­by­zero error—allows the program
    * to continue. However, an array boundary error is caught by the outer try, which causes the program to terminate.
    *
    * Although certainly not the only reason for nested try statements, the preceding program makes an important
    * point that can be generalized. Often nested try blocks are used to allow different categories of errors to
    * be handled in different ways. Some types of errors are catastrophic and cannot be fixed. Some are minor and
    * can be handled immediately. You might use an outer try block to catch the most severe errors, allowing
    * inner try blocks to handle less serious ones.
    * */

    /************************************** 8.7 Throwing an exception *************************************/

    /*
    * Exception can be generated by JVM, or manually throw by using throw statement. Its general form is shown here:
    * throw exceptOb;
    *
    * Notice exceptOb must be an object of an exception class derived from Throwable. As throw statement throws an
    * object. Thus we must create an object for it to throw, that's why we need to use new to create a new object.
    * check ExceptionExp1.exp8() and code fragment 8.7 to see how we throw an exception.
    * */

    /** 8.7.1. Rethrowing an exception
     * An exception caught by one catch statement can be rethrown so that it can be caught
     * by an outer catch. The most likely reason for rethrowing this way is to allow multiple
     * handlers access to the exception. For example, perhaps one exception handler manages
     * one aspect of an exception, and a second handler copes with another aspect.
     * Remember, when you rethrow an exception, it will not be recaught by the same catch
     * statement. It will propagate to the next catch statement. Check ExceptionExp1.exp9(); As exc is already an
     * object, so we can throw it directly
     *
     * */

    /** 8.7.2 Why would I want to manually throw an exception?
     *
     * Most often, the exceptions that you will throw will be instances of exception classes that you created. As
     * you will see later in this chapter, creating your own exception classes allows you to handle errors in your
     * code as part of your program’s overall exception handling strategy.
     * */

    /************************************** 8.8 A Methods in throwable *************************************/
    /*
    * As explained, all exceptions are subclasses of Throwable, all exceptions support the methods defined by Throwable.
    * Several commonly used methods are shown in the following table:
    * - Throwable fillInStackTrace() : Returns a Throwable object that contains a completed stack trace. This object
    *                                  can be rethrown.
    * - String getLocalizedMessage() : Returns a localized description of the exception
    * - String getMessage() : Returns a description of the exception
    * - void printStackTrace(): Displays the stack trace
    * - void printStackTrace(PrintStream stream) : Sends the stack trace to the specified stream.
    * - void printStackTrace(PrintWriter stream) : Sends the stack trace to the specified stream.
    * - String toString() : Returns a String object containing a complete description of the exception. This method
    *                       is called by println() when outputting a Throwable object.
    *
    * printStackTrace() are very common to use, when you need to display the standard error message plus
    * a record of the method calls that lead up to the exception. And toString() display the standard error message.
    * Check code fragment 8.8 to see an example of toString and printStackTrace
    *
    * */

    /************************************** 8.9 Using finally *************************************/

    /*
    * Sometimes you will want to define a block of code that will execute when a try/catch block is left. For example,
    * an exception might cause an error that terminates the current method, causing its premature return. However,
    * that method may have opened a file or a network connection that needs to be closed. Such types of circumstances
    * are common in programming, and Java provides a convenient way to handle them: finally.
    *
    * The general form of a try/catch that includes finally is shown here.
    * try {
    * // block of code to monitor for errors
    * }
    * catch (ExcepType1 exOb) {
    * // handler for ExcepType1
    * }
    * catch (ExcepType2 exOb) {
    * // handler for ExcepType2
    * }
    * //...
    * finally {
    * // finally code }
    *
    * The finally block will be executed whenever execution leaves a try/catch block, no matter what conditions cause
    * it. That is, whether the try block ends normally, or because of an exception, the last code executed is that
    * defined by finally. The finally block is also executed if any code within the try block or any of its catch
    * statements return from the method.
    *
    * Check the code fragment ExceptionExp1.exp10(); even with return statement, the finally statement is always
    * executed after entering try catch clause.
    * */

    /************************************** 8.10 Using throws *************************************/
/*
* In some cases, if a method generates an exception that it does not handle, it must declare that exception in a throws
* clause. Here is the general form of a method that includes a throws clause:
* ret­type methName(param­list) throws exception­list {
*  // body
* }
* Here, exception­list is a comma­separated list of exceptions that the method might throw outside of itself.
* Some exceptions that are subclass of Error or RuntimeException don't need to be specified in a throws list. These
* subclass exceptions are also called unchecked exception. We can't check them during compile time. For all other
* subclass, we called them checked exception, they need to be declared. Failure to do so causes a compile-time error.
*
*  */

    /************************************** 8.11 Additional exception features *************************************/

    /*
    * Beginning with JDK 7, Java's exception handling mechanism was expanded with the addition of three features:
    * 1. Automatic resource management: which automates the process of releasing a resource, such as a file, when it
    *    is no longer needed. It is based on an expanded form of try, called the try­with­resources statement, and it
    *    will be covered in section 9.
    * 2. Multi­catch:  which allows two or more exceptions to be caught by the same catch clause. As you learned
    *    earlier, it is possible (indeed, common) for a try to be followed by two or more catch clauses. Although
    *    each catch clause often supplies its own unique code sequence, it is not uncommon to have situations in
    *    which two or more catch clauses execute the same code sequence even though they catch different exceptions.
    *    Instead of having to catch each exception type individually, you can use a single catch clause to handle the
    *    exceptions without code duplication.
    * 3. Rethrow/(final rethrow): which Allows you to catch an exception type and it's subtype and rethrow it without
    *    having to add a throws clause to the method signature.
    * */


    /** 8.11.1 Multi catch
     * To create a multi­catch, specify a list of exceptions within a single catch clause. You do
     * this by separating each exception type in the list with the OR operator. Each multi­
     * catch parameter is implicitly final. (You can explicitly specify final, if desired, but it is
     * not necessary.) Because each multi­catch parameter is implicitly final, it can't be
     * assigned a new value. Check ExceptionExp1.exp11(); to see an example
     * */

    /** 8.11.2 Final rethrow
     * It restricts the type of exceptions that can be rethrown to only those checked
     * exceptions that the associated try block throws, that are not handled by a preceding catch clause, and that
     * are a subtype or supertype of the parameter.While this capability might not be needed often, it is now
     * available for use. For the final rethrow feature to be in force, the catch parameter must be effectively
     * final. This means that it must not be assigned a new value inside the catch block. It can also be explicitly
     * specified as final, but this is not necessary.
     * check this page for more details
     * https://www.theserverside.com/tutorial/OCPJP-Use-more-precise-rethrow-in-exceptions-Objective-Java-7
     * */

    /************************************** 8.12 Java built-in exceptions *************************************/

    /*
    * Inside the standard package java.lang, Java defines several exception classes. The most general of these
    * exceptions are subclasses of the standard type RuntimeException. Since java.lang is implicitly imported into
    * all Java programs many exceptions derived from RuntimeException are automatically available. Furthermore, they
    * need not be included in any method’s throws list. In the language of Java, these are called unchecked exceptions
    * because the compiler does not check to see if a method handles or throws these exceptions.
    *
    * Other exceptions defined by java.lang that must be included in a method’s throws list if that method can
    * generate one of these exceptions and does not handle it itself. These are called checked exceptions. In
    * addition to the exceptions in java.lang, Java defines several other types of exceptions that relate to other
    * packages, such as IOException.
    * */

    /** 8.12 What is a chained exceptions?
     *
     * Chained exceptions were added to Java by JDK 1.4. The chained exception
     * feature allows you to specify one exception as the underlying cause of another. For
     * example, imagine a situation in which a method throws an ArithmeticException
     * because of an attempt to divide by zero. However, the actual cause of the problem
     * was that an I/O error occurred, which caused the divisor to be set improperly.
     * Although the method must certainly throw an ArithmeticException, since that
     * is the error that occurred, you might also want to let the calling code know that the
     * underlying cause was an I/O error. Chained exceptions let you handle this, and any
     * other situation, in which layers of exceptions exist.
     *
     * To allow chained exceptions, two constructors and two methods were added to Throwable. The constructors are
     * shown here:
     * Throwable(Throwable causeExc)
     * Throwable(String msg, Throwable causeExc)
     *
     * These methods are shown here:
     * Throwable getCause( )
     * Throwable initCause(Throwable causeExc)
     *
     * In the first constructor, causeExc is the exception that causes the current exception. That
     * is, causeExc is the underlying reason that an exception occurred. The second form
     * allows you to specify a description at the same time that you specify a cause
     * exception. These two constructors have also been added to the Error, Exception,
     * and RuntimeException classes.
     *
     * The getCause( ) method returns the exception that underlies the current
     * exception. If there is no underlying exception, null is returned. The initCause( )
     * method associates causeExc with the invoking exception and returns a reference to
     * the exception. Thus, you can associate a cause with an exception after the
     * exception has been created. In general, initCause( ) is used to set a cause for
     * legacy exception classes that don’t support the two additional constructors
     * described earlier.
     * */

    /************************************** 8.13 Creating exception subclass *************************************/

    /*
    * Although Java’s built­in exceptions handle most common errors, Java’s exception handling mechanism is not
    * limited to these errors. In fact, part of the power of Java’s approach to exceptions is its ability to handle
    * exception types that you create. Through the use of custom exceptions, you can manage errors that relate
    * specifically to your application. Creating an exception class is easy. Just define a subclass of Exception
    * (which is, of course, a subclass of Throwable). Your subclasses don’t need to actually implement anything—it
    * is their existence in the type system that allows you to use them as exceptions.
    *
    * The Exception class does not define any methods of its own. It does, of course, inherit those methods provided
    * by Throwable. Thus, all exceptions, including those that you create, have the methods defined by Throwable
    * available to them. Of course, you can override one or more of these methods in exception subclasses that you
    * create.
    *
    * Check NonIntResultException class to see an example of custom exception. Notice an exception class
    * is like any other class, it has constructor, you can override methods which exist in its super class
    * and the access modifier works like regular class too.
    * */

    /************************************** 8.14 When should we use exception? *************************************/


    /*
    * Since the Java API makes extensive use of exceptions to report errors, nearly all real­world programs will
    * make use of exception handling. This is the part of exception handling that most new Java programmers find
    * easy. It is harder to decide when and how to use your own custom­made exceptions. In general, errors can be
    * reported in two ways: return values and exceptions. When is one approach better than the other? Simply put,
    * in Java, exception handling should be the norm. Certainly, returning an error code is a valid alternative in
    * some cases, but exceptions provide a more powerful, structured way to handle errors. They are the way
    * professional Java programmers handle errors in their code.
    * */

    public static void main(String[] args){
        /** 8.2 Exception handling basics*/
        // ExceptionExp1.exp1();

        // ExceptionExp1.exp2();

        /** 8.3 The uncaught exception*/
        // ExceptionExp1.exp3();
        // ExceptionExp1.exp4();
       // ExceptionExp1.exp5();
        /** 8.5 Catch subclass exception*/
       // ExceptionExp1.exp6();

        /** 8.6 nest try block*/
       // ExceptionExp1.exp7();

        /** 8.7 Throwing an exception*/
        /*try {
            ExceptionExp1.exp8(12);
        }
        catch (IllegalArgumentException exc){
            System.out.println(exc.toString());
        }*/
/*
        try {
            ExceptionExp1.exp9(12);
        }
        catch (IllegalArgumentException exc){
            System.out.println("This is the upper try catch "+exc.toString());
        }*/

        /** 8.8 Methods in throwable */
      /*  try {
            ExceptionExp1.exp8(12);
        }
        catch (IllegalArgumentException exc){
            System.out.println(exc);
            exc.printStackTrace();
        }*/

      /** 8.9 Using finally */
      // ExceptionExp1.exp10();

        /** 8.11 Additional feature*/
       // ExceptionExp1.exp11();

        /** 8.12 custom exception class*/

        /* Notice the following example, throw exception break the loop and the catch happens outside the loop.
        * The loop will not restart. If you don't want the exception handling break your loop, you need to
        * handle it inside your loop. See  ExceptionExp1.exp14(); */
       /* try {
            ExceptionExp1.exp13();
        } catch (NonIntResultException e) {
            System.out.println(e);
        }*/

       ExceptionExp1.exp14();

    }
}
